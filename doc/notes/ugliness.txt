//---------------------------------------------------------------------------
9/24/13

Routemanager (and log system) uses the startup function to walk a hierarchy of objects and set parenting hierarchy info; this is done so that we can track the hierarchy no matter what order the objects are created.
Is there a better way to do this?
//---------------------------------------------------------------------------








//---------------------------------------------------------------------------
9/27/13
we have objects called MewloPackages -- might be too confusing with python term of "packages"
can we rename it to something similar like "packs"?
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
9/27/13
i'd like to standardize all startup and shutdown functions to take an eventlist and report issues.
and create debug log entries with startup reports.

alternatively, rethink how we are treating these startup events specially, and ask if we really want to do that, or if we shouldnt let them use normal logging for errors
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
10/1/13
if you look in misc.py you will see some functions that return Events for exceptions
and some functions that raise exceptions.

we need a systematic explanation of when/why some functions catch exceptions and return them as events vs those which pass exceptions up the chain
and a systematic documentation to make this clear for any given function at a glance.
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
10/1/13
take a look at a file like package.py
note that its impossible to distinguish between api functions meant to be called by someone, vs helper functions used by these.
move all "internal" functions to _ prefixes?
by internal i mean functions not meant to be called from outside the class
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
10/3/13
reduce use of the "from x import y" stuff, as it makes circular dependencies
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
10/8/13
See mglobals for some SERIOUSLY evil python ugliness and problematic thing going on with python reloading modules and wiping out class/module state.
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
10/9/13
Do we want to make our internal logging system more like python built-in logging system?
Or even rewrite ours to use the built in one for most work?
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
10/11/13
we have another naming clash --
we call two different kinds of things settings, specifically dbsettings.
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
10/13/13
The database files are a bit of a mess, and we're veering off the keeping separate of non-mewlo and mewlo classes,
and in the case of database manager, the sqlalchemy vs non-sqlalchemy stuff.
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
10/13/13
We have made sure database stuff can be fully accessed at low (sqlalchemy) level.
For most stuff this is already possible.  One exception is the "mapper" and "table" functions for models and sqlalchemy, which currently cannot be overwridden by model classes.
Consider restructuring database division of labor.
Our first idea was to make an sqlalchemy-specific derived MANAGER, and leave the models neutral about the back-end engine.
But this may be untenable, and it may make more sense to let the MODELS be sql-alchemy derived and leave the manager neutral?
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
10/13/13
Refactor the settings class so that we dont need to INTERCEPT normal settings functions, but use pre/post op functions
//---------------------------------------------------------------------------
