"""
mverificationmanager.py
Helper for verifications data
"""


# mewlo imports
from ..manager import modelmanager
from ..eventlog.mevent import EFailure, EException
import mverification







class MewloVerificationManager(modelmanager.MewloModelManager):
    """The MewloVerificationManager class helps verification management."""


    def __init__(self, mewlosite, debugmode):
        super(MewloVerificationManager,self).__init__(mewlosite, debugmode, mverification.MewloVerification)

    def startup(self, eventlist):
        super(MewloVerificationManager,self).startup(eventlist)

    def shutdown(self):
        super(MewloVerificationManager,self).shutdown()


    def dumps(self, indent=0):
        """Return a string (with newlines and indents) that displays some debugging useful information about the object."""
        outstr = " "*indent + "MewloVerificationManager (" + self.__class__.__name__ + ") reporting in.\n"
        return outstr



    def create_verification(self, verification_type):
        """
        Generic creation of a new verification entry.
        """
        verification = self.modelclass()
        verification.verification_type = verification_type      
        return verification
    
    
    

    def find_bylongcode(self, verification_code):
        """
        Find a verification entry by long code.
        We don't check for expiration or anything like that here, we just find the matching code.
        ATTN: TODO - this is only useful for LONG codes -- we need something more to choose short codes, such as requiring additional info
        """
        verification = self.modelclass.find_one_bykey({'verification_code':verification_code})
        return verification




    
    
    def basic_validation(self, verification, verification_code, request, verification_type_expected, is_shortcode_expected):
        """Perform basic validation (check for expiration, etc.).
        Return failure if it fails."""

        # is this even a valid verification?
        if (verification == None):
            return EFailure("Verification code not found.")

        # does code match?
        if (verification.verification_code != verification_code):
            return EFailure("This verification code does not match.")
        
        # sanity check
        if ((verification_code == None) or (verification_code == '')):
            return EFailure("This verification code is blank.")

        # is it already consumed?
        if (verification.date_consumed != None):
            return EFailure("This verification code was already used on {0}.".format(verification.nice_datestring(verification.date_consumed)))

        # is it marked invalid?
        if (verification.invalidreason != None):
            return EFailure("This verification code is no longer valid ({0}).".format(verification.invalidreason))
        
        # is it the right type?
        if ((verification_type_expected != None) and (verification.verification_type != verification_type_expected)):
            return EFailure("This verification code is not of the expected type.")

        # is it the right type?
        if ((is_shortcode_expected != None) and (verification.is_shortcode != is_shortcode_expected)):
            return EFailure("This verification code is not of the expected size.")
        
        # short codes must match client session or use
        if (verification.is_shortcode):
            session = request.get_session(False)
            if (session == None):
                # no session for current client, that's going to be a fail, just a matter of how we explain it to user
                if (verification.user_id == None):
                    # this request was generated by a non-logged-in user, and the current client has no session, so advise them to make sure sessions are possible via cookies
                    return EFailure("This short verification code cannot be used because you were not recognized as the same person who generated it.  Please ensure that your browser accepts cookies and then request a new code.")
                else:
                    # since this code was requested by a logged in user, we can tell them to log in first
                    return EFailure("This short verification code cannot be used because you were not recognized as the same person who generated it.  Please login first.")
            # ok there is a session for this user client (could be a logged in user or session could be == None)
            user = session.get_user()
            if ((verification.user_id != None) and (user != None) and (verification.user_id == user.id)):
                # ok we matched the logged in user -- so that's good enough for us, regardless if session matches
                pass
            elif ((verification.session_id != None) and (verification.session_id == session.id)):
                # ok the session id matches -- that's good enough for us
                pass
            else:
                # ok they do not match the session id or user id
                return EFailure("This short verification code cannot be used because you were not recognized as the same person who generated it.  Please request a new code.")
            

        # is it expired?
        nowtime = verification.get_nowtime()        
        if ((verification.date_expires != None) and (verification.date_expires > nowtime)):
            return EFailure("This verification code has expired.")
        
        # it's good, no error
        return None
    
    




    def find_byshortcode(self, verification_type, request):
        """
        Find a verification entry by type and request session/user info.
        We don't check for expiration or anything like that here, we just find the matching code.
        IMPORTANT: Note that we don't look it up by code!! That's because there can only be one short code per type+user/session; that is how we ensure that they can't try all possible codes.
        On basic validation we will check actual code.
        """
        # ATTN: unfinished
        
        # build the where clause
        whereclause = self.build_whereclause_verifications_by_type_and_request(verification_type, request)
        if (whereclause == None):
            return

        # ok find it
        verification = self.modelclass.find_one_bywhereclause(whereclause)
        return verification 
    


    def invalidate_previousverifications(self, verification_type, request):
        """
        We often want to invalidate previous verification entries from a user of a specific type, before creating a new one of the same type, so that there is only one pending verification usable at a time.
        """

        # build the where clause
        whereclause = self.build_whereclause_verifications_by_type_and_request(verification_type, request)
        if (whereclause == None):
            return

        # if we wanted we could outright DELETE these verifications
        if (False):
            self.modelclass.delete_all_bywhereclause(whereclause)
        else:
            # or we could mark them as invalidated but leave them in place in order to give user a better error if they try to use it
            updatedict = {
                'invalidreason': "A more recent verification request was submitted.",
                'date_consumed': self.modelclass.get_nowtime()
            }
            # add sessionip
            session = request.get_session(False)
            if (session != None):            
                updatedict['ip_consumed'] = session.ip
            # ok update them
            self.modelclass.update_all_dict_bywhereclause(updatedict, whereclause)



    def build_whereclause_verifications_by_type_and_request(self, verification_type, request):
        """Build whereclause to select the verifications.
        We want to identify all verifications that match: verification_type AND (EITHER the sessionid or userid)
        """

        # get session information for user, if none, then we have no user or session so nothing to do
        session = request.get_session(False)
        if (session == None):
            return None
        user = session.get_user()
        
        # build the where clause
        whereclause = 'verification_type = "{0}"'.format(verification_type)

        if (user == None):            
            whereclause += ' AND session_id = {0}'.format(session.id)
        else:
            whereclause += ' AND (session_id = {0} OR user_id = {1})'.format(session.id, user.id)
            
        #print "USING whereclause = "+whereclause
            
        # return it
        return whereclause
    